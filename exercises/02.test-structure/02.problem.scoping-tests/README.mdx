# Scoping tests

It looks like a bug found its way into our code! But before you do anything, let's run the tests to help us figure out what's wrong. In the end, that's exactly what we write them for, isn't it?

```sh nonumber
node greet.js
```

```
# TODO: OUTPUT HERE
```

We can see a failing assertion but it's not immediately clear what the problematic code is. Is it a bug in the `greet` function or in the `goodbye`? It may take a minute to find the culprit by looking around, we only have two test cases, after all. But what will we do once we have three, thirty, three hundred tests? Suddenly, that minute becomes half an hour, or an hour, or a whole day. So much time wasted on _debugging tests_ instead of _fixing the issue_.

Let's address this shortcoming by giving each test its own room to live in. Because just as we have benefited from a declarative `expect()` abstraction, we can save ourselves hours of confusion simply by providing a more declarative `test()` API for our tests:

```js
test('first test', () => {
	expect(actual).toBe(expected)
})

test('second test', () => {
	expect(actual).toBe(expected)
})
```

... Mention that naming tests is important. I think linking to "what makes a great test name" tip is great in the FINISHED.

```
✗ first test
  Error: Expected "5" to equal to "10"

✓ second test
```

Your goal right now is to write the `test()` function and wrap both existing tests in it. As the result, it should print the correct test status (success/failure) for each test.

<callout-info>
	Tip: Since the `expect()` assertions _throw_ when something is wrong with the
	tested code, perhaps you should _try_ and _catch_ those assertion errors!
</callout-info>
